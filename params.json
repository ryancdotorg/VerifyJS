{"name":"VerifyJS","tagline":"Load JavaScript from a CDN, no trust required!","body":"VerifyJS\r\n========\r\n**Load JavaScript from a CDN, no trust required!**\r\n\r\nVerifyJS is yet another asyncronous JavaScript/CSS loader with a unique\r\nfeature - it guarantees that the asset you're loading hasn't been tampered\r\nwith or otherwise modified without your knowledge. This is acomplished by\r\nproviding it with both a asset's location and a cryptographic checksum of\r\nits content.\r\n\r\n**Important:** Please review the license. It places some restrictions on use\r\nand distribution to encourage secure configurations. Also note that this is\r\nnot yet a stable release.\r\n\r\nFeatures\r\n--------\r\n* Asyncronously load JS and CSS\r\n* Execute either 'in-order' or 'as soon as ready'\r\n* Specify callbacks for various events (success, verified, error,\r\n  timeout, etc) and/or when everything has loaded\r\n* Broad browser support - works with mobile browsers, Safari, Chrome,\r\n  Firefox and IE8+\r\n* Small - less than 2.5KB minified, 1.5KB gzipped\r\n* Known to work with cdnjs and jsdelivr\r\n* Ensure that assets are not executed more than once\r\n* Verify asset content with sha256 and execute only if it matchs\r\n\r\nLimitations\r\n-----------\r\n* In order to see the content of an asset before injecting it, a XMLHTTPRequest\r\n(or on older versions of IE, XDomainRequest) must be used. This requires\r\nthe server you're loading an asset from to send CORS headers, which many don't.\r\n* The security gain is very specific - you get to load assets from somewhere\r\n  that you don't entierly trust. In particular, VerifyJS cannot be counted\r\n  on to protect against malicious modification to your page, whether by a\r\n  man-in-the-middle or someone pwning your server.\r\n* Using it with 'the latest version' of anything or assets that are likely to\r\n  change without notice will end in tears.\r\n* To give a specific example, loading google analytics isn't be supported by\r\n  VerifyJS. You can load it without VerifyJS but you must then trust that\r\n  it will neither do anything evil nor be tampered with in transit.\r\n* VerifyJS cannot protect against assets you load in turn requesting other\r\n  assets.\r\n* VerifyJS's sha256 implementation is optimized for small size, not speed.\r\n  In newer browsers this shouldn't be a problem. In IE8 you may get the \"slow\r\n  script warning\" trying to load even a moderatly large (25-50KB) asset. If you\r\n  need to support IE8, please see the examples section.\r\n\r\nUsage and Examples\r\n------------------\r\n\r\nLoad VerifyJS (include):\r\n\r\n    <script type=\"text/javascript\" src=\"verify-min.js\"></script>\r\n\r\nLoad VerifyJS (inline):\r\n\r\n    <script>\r\n    VerifyJS=function(){...(copy/paste the code)\r\n    </script>\r\n\r\nA global VerifyJS object will be created, no need to do anything with `new`.\r\n\r\nIf you're going to be loading scripts that are more than 10-20KB and care\r\nabout supporting IE8, include a snippet like this right after you load\r\nVerifyJS, otherwise you're likely to trigger a 'slow script' warning.\r\n\r\n    <!-- https://github.com/ryancdotorg/async-sha256-js -->\r\n    <!--[if lte IE 8]>\r\n    <script type=\"text/javascript\" src=\"async-sha256-min.js\"></script>\r\n    <script>\r\n    (function(){\r\n      var sha256 = new AsyncSha256();\r\n      VerifyJS.hash = function(m, c) {\r\n        sha256.adigest(m, c);\r\n      };\r\n    })();\r\n    </script>\r\n    <![endif]-->\r\n\r\nDefine a basic callback handler that logs to the console:\r\n\r\n    <script>\r\n    var logger = function(data) {\r\n      var file = data.uri.split('/').slice(-1);\r\n      var msg = 'VerifyJS: ';\r\n      switch(data.result) {\r\n        /* only triggered via VerifyJS.add() */\r\n        case VerifyJS.VERIFIED:\r\n          msg += 'Download and verification of ' + file + ' successful.';\r\n          break;\r\n        case VerifyJS.SUCCESS:\r\n          msg += 'Successfully loaded ' + file + ' into the DOM.';\r\n          break;\r\n        case VerifyJS.E_HASH:\r\n          msg += 'Content for ' + file + ' did not match the specified hash! ';\r\n          msg += 'Got ' + data.hash + '.';\r\n          break;\r\n        /* no special handling for E_LOAD, E_TIMEOUT, or E_PARSE */\r\n        case default:\r\n          msg += 'Failed to load ' + file + '!';\r\n          break;\r\n       }\r\n       console.log(msg);\r\n    }\r\n    </script>\r\n\r\nLoad a script and inject it into the DOM as soon as it finishes loading:\r\n\r\n    VerifyJS.load('//cdnjs.cloudflare.com/ajax/libs/Base64/0.2.1/base64.min.js',\r\n                  'dd840cf1948276189475392e2fe0f4a8a336d6708f320d08358df6fbdf22f990',\r\n                  logger);\r\n\r\nLoad jQuery and some plugins with in-order execution, and an 'everything finished' callback:\r\n\r\n    VerifyJS.add('http://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.js',\r\n                 'ce0343e1d6f489768eeefe022c12181c6a0822e756239851310acf076d23d10c',\r\n                 logger);\r\n    VerifyJS.add('//cdn.jsdelivr.net/jquery.serializejson/1.2.3/jquery.serializejson.min.js',\r\n                 'ff82686aeec7776efeee93f6bd9013b23a58f012db59bd071ea0130b4fe71c14',\r\n                 logger);\r\n    VerifYJS.add('http://cdnjs.cloudflare.com/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js',\r\n                 'f4ccf02b69092819ac24575c717a080c3b6c6d6161f1b8d82bf0bb523075032d',\r\n                 logger);\r\n    VerifyJS.done(function() {\r\n      $('body').text('Everything has loaded successfully!');\r\n    });\r\n\r\nIf you're using the standard version (verify-min.js, not verify-nocss-min.js), loading stylesheets will work as well.\r\n\r\nObjections\r\n----------\r\n* [Javascript Cryptography Considered Harmful](http://www.matasano.com/articles/javascript-cryptography/)!\r\n\r\nI almost entirely agree with that article. Let me be *very* clear about what\r\nVerifyJS offers: preventing a malicious or pwned CDN from passing you Evil\r\ncode. Nothing more, but that alone is useful.\r\n\r\n* The NSA can break sha256!\r\n\r\nI doubt it, but it doesn't matter. They have far more convenient ways to mess\r\nwith you using their arsenal of 0day exploits.\r\n\r\n* Bitcoin ASICs will break sha256!\r\n\r\nTo do a preimage attack on sha256 through brute force requires an average of\r\n2^255 hash operations. In a day the bitcoin network currently does on the\r\norder of 2^74 hash operations per day. Doing 2^255 sha256 operations would\r\nrequire 2^255/2^74 = 2^181 days. That is about a trillion times longer than\r\nour estimates of how long we have until the sun burns out.\r\n\r\n* Your license is weird!\r\n\r\nVerifyJS is a security tool, and I wish to ensure that it is used correctly.\r\nEnforcing that via technical measures would be difficult so I have prohibited\r\nsome of the more egregiously wrong ways to use it in the license. If you have\r\na good use case that you feel the license disallows please contact me and I\r\nwill try to work something out with you.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}